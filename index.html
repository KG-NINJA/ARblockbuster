<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gesture Breakout Pro</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }
    .container {
      width: min(95vw, 1400px);
      height: 95vh;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 1.5rem;
      box-shadow: 0 0 60px rgba(0, 212, 255, 0.2);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }
    header {
      padding: 1.5rem 2rem;
      background: linear-gradient(90deg, rgba(0, 212, 255, 0.1), rgba(0, 150, 255, 0.05));
      border-bottom: 1px solid rgba(0, 212, 255, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .header-title {
      font-size: 1.8rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
    }
    .header-stats {
      display: flex;
      gap: 2rem;
    }
    .stat {
      text-align: center;
    }
    .stat-label {
      font-size: 0.8rem;
      color: rgba(0, 212, 255, 0.7);
      text-transform: uppercase;
    }
    .stat-value {
      font-size: 1.6rem;
      font-weight: 700;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }
    .main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 1.5rem;
      padding: 1.5rem;
      overflow: hidden;
    }
    .canvas-wrapper {
      position: relative;
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 1rem;
      overflow: hidden;
    }
    video, canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      inset: 0;
    }
    video { opacity: 0.2; object-fit: cover; }
    .sidebar { display: flex; flex-direction: column; gap: 1.2rem; }
    .card {
      background: rgba(0, 212, 255, 0.08);
      border: 1px solid rgba(0, 212, 255, 0.2);
      padding: 1.2rem;
      border-radius: 0.8rem;
    }
    .btn {
      width: 100%;
      padding: 0.8rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(0,212,255,0.5);
      background: rgba(0,212,255,0.1);
      color: #00d4ff;
      cursor: pointer;
      font-weight: 700;
      transition: all 0.3s;
    }
    .btn:hover:not(:disabled) {
      background: rgba(0,212,255,0.2);
      box-shadow: 0 0 15px rgba(0,212,255,0.4);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .badge {
      padding: 0.6rem 0.8rem;
      border-radius: 0.5rem;
      border: 1px solid rgba(0,212,255,0.3);
      background: rgba(0,212,255,0.05);
      color: #00d4ff;
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.6rem;
    }
    .badge.active {
      border-color: #00ff88;
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
    }
    .info-text {
      font-size: 0.85rem;
      line-height: 1.5;
      color: rgba(255,255,255,0.6);
    }
  </style>
</head>
<body>
<div class="container">
  <header>
    <div class="header-title">ðŸŽ® GESTURE BREAKOUT PRO</div>
    <div class="header-stats">
      <div class="stat">
        <div class="stat-label">Score</div>
        <div class="stat-value" id="score">0</div>
      </div>
      <div class="stat">
        <div class="stat-label">Level</div>
        <div class="stat-value" id="level">1</div>
      </div>
      <div class="stat">
        <div class="stat-label">Lives</div>
        <div class="stat-value" id="lives">3</div>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="canvas-wrapper">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
    </div>

    <div class="sidebar">
      <div class="card">
        <button class="btn" id="start-btn">START</button>
        <button class="btn" id="reset-btn">RESET</button>
      </div>
      <div class="card">
        <div id="cam-badge" class="badge">ðŸ“¹ Camera</div>
        <div id="hand-badge" class="badge">âœ‹ Hands</div>
      </div>
      <div class="card info-text" id="info">
        Move your hand to control the paddle
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const startBtn = document.getElementById("start-btn");
const resetBtn = document.getElementById("reset-btn");
const infoEl = document.getElementById("info");
const scoreEl = document.getElementById("score");
const levelEl = document.getElementById("level");
const livesEl = document.getElementById("lives");
const camBadge = document.getElementById("cam-badge");
const handBadge = document.getElementById("hand-badge");

let videoReady = false;
let gameRunning = false;
let score = 0;
let level = 1;
let lives = 3;
let combo = 0;

let hands;
let handX = null;

const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

let paddle = { x: 350, y: 550, w: 100, h: 20 };
let ball = { x: 400, y: 300, vx: 5, vy: -5, r: 8 };
let blocks = [];
let powerUps = [];

const FIX_SPEED = 6;

function normalizeBallSpeed() {
  const len = Math.hypot(ball.vx, ball.vy);
  if (len === 0) return;
  ball.vx = (ball.vx / len) * FIX_SPEED;
  ball.vy = (ball.vy / len) * FIX_SPEED;
}

function initBlocks() {
  blocks = [];
  const rows = 4 + level;
  const cols = 8;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const colors = ["#00ffaa", "#00d4ff", "#ff00aa", "#ffff00"];
      blocks.push({
        x: 20 + x * 95,
        y: 30 + y * 35,
        w: 85,
        h: 25,
        alive: true,
        color: colors[y % colors.length],
        points: (rows - y) * 10
      });
    }
  }
}

function createPowerUp(x, y, type) {
  powerUps.push({
    x: x,
    y: y,
    vx: (Math.random() - 0.5) * 4,
    vy: 3,
    type: type,
    r: 8
  });
}

function collideRect(ball, rect) {
  return (
    ball.x + ball.r > rect.x &&
    ball.x - ball.r < rect.x + rect.w &&
    ball.y + ball.r > rect.y &&
    ball.y - ball.r < rect.y + rect.h
  );
}

async function initHands() {
  hands = new Hands({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 0,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  hands.onResults(results => {
    const lm = results.multiHandLandmarks;
    const detected = lm && lm.length > 0;
    handBadge.classList.toggle("active", detected);
    if (!detected) return;
    const tip = lm[0][8];
    handX = tip.x * canvas.width;
  });
}

async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    video.play();
    videoReady = true;
    camBadge.classList.add("active");

    const cam = new Camera(video, {
      onFrame: async () => { await hands.send({ image: video }); }
    });
    cam.start();
  } catch (e) {
    infoEl.textContent = "Camera error: " + e.message;
  }
}

startBtn.onclick = async () => {
  if (!videoReady) {
    startBtn.textContent = "Initializing...";
    await initHands();
    await initCamera();
    startBtn.textContent = "START";
  }

  level = 1;
  score = 0;
  lives = 3;
  combo = 0;
  initBlocks();
  normalizeBallSpeed();
  
  scoreEl.textContent = score;
  levelEl.textContent = level;
  livesEl.textContent = lives;
  
  gameRunning = true;
  startBtn.disabled = true;
  infoEl.textContent = "Level " + level + " - Go!";
};

resetBtn.onclick = () => {
  gameRunning = false;
  startBtn.disabled = false;
  score = 0;
  level = 1;
  lives = 3;
  scoreEl.textContent = 0;
  levelEl.textContent = 1;
  livesEl.textContent = 3;
  infoEl.textContent = "Press START to play";
};

function playSound(freq, duration) {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function loop() {
  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;

  ctx.fillStyle = "rgba(10,14,39,0.3)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = "rgba(0,212,255,0.05)";
  for (let x = 0; x < canvas.width; x += 60) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += 60) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  if (gameRunning) {
    if (handX !== null) {
      paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, handX - paddle.w / 2));
    }

    ball.x += ball.vx;
    ball.y += ball.vy;

    if (ball.x < ball.r || ball.x > canvas.width - ball.r) ball.vx *= -1;
    if (ball.y < ball.r) ball.vy *= -1;

    if (collideRect(ball, paddle)) {
      ball.vy = -Math.abs(ball.vy);
      const diff = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
      ball.vx = diff * FIX_SPEED * 0.8;
      combo += 1;
      playSound(800, 0.1);
    }

    blocks.forEach(b => {
      if (b.alive && collideRect(ball, b)) {
        ball.vy *= -1;
        b.alive = false;
        score += b.points * combo;
        scoreEl.textContent = score;
        playSound(1200, 0.1);
        if (Math.random() < 0.2) createPowerUp(b.x + b.w / 2, b.y, "expand");
        if (Math.random() < 0.1) createPowerUp(b.x + b.w / 2, b.y, "slowball");
      }
    });

    powerUps = powerUps.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      
      if (collideRect(p, paddle)) {
        if (p.type === "expand") paddle.w = Math.min(200, paddle.w + 30);
        if (p.type === "slowball") {
          ball.vx *= 0.7;
          ball.vy *= 0.7;
        }
        playSound(1500, 0.15);
        return false;
      }
      return p.y < canvas.height;
    });

    if (ball.y > canvas.height) {
      combo = 0;
      lives -= 1;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameRunning = false;
        infoEl.textContent = "Game Over! Final Score: " + score;
        startBtn.disabled = false;
      } else {
        ball.x = paddle.x + paddle.w / 2;
        ball.y = paddle.y - 30;
        ball.vx = 5;
        ball.vy = -5;
        normalizeBallSpeed();
      }
    }

    if (blocks.filter(b => b.alive).length === 0) {
      level += 1;
      levelEl.textContent = level;
      initBlocks();
      ball.x = paddle.x + paddle.w / 2;
      ball.y = paddle.y - 30;
      combo = 0;
      infoEl.textContent = "Level " + level + " - Ready!";
    }
  }

  blocks.forEach(b => {
    if (!b.alive) return;
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.strokeStyle = "rgba(255,255,255,0.3)";
    ctx.lineWidth = 1;
    ctx.strokeRect(b.x, b.y, b.w, b.h);
  });

  powerUps.forEach(p => {
    ctx.fillStyle = p.type === "expand" ? "#ffff00" : "#00ff00";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.fillStyle = "#00ffaa";
  ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

  ctx.fillStyle = "#ff00aa";
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.fill();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
